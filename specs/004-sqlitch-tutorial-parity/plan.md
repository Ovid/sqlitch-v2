
# Implementation Plan: SQLite Tutorial Parity

**Branch**: `004-sqlitch-tutorial-parity` | **Date**: 2025-10-07 | **Spec**: [Feature Spec](spec.md)
**Input**: Feature specification from `/specs/004-sqlitch-tutorial-parity/spec.md`

## Execution Flow (/plan command scope)
```
1. Load feature spec from Input path
   → If not found: ERROR "No feature spec at {path}"
2. Fill Technical Context (scan for NEEDS CLARIFICATION)
   → Detect Project Type from file system structure or context (web=frontend+backend, mobile=app+api)
   → Set Structure Decision based on project type
3. Fill the Constitution Check section based on the content of the constitution document.
4. Evaluate Constitution Check section below
   → If violations exist: Document in Complexity Tracking
   → If no justification possible: ERROR "Simplify approach first"
   → Update Progress Tracking: Initial Constitution Check
5. Execute Phase 0 → research.md
   → If NEEDS CLARIFICATION remain: ERROR "Resolve unknowns"
6. Execute Phase 1 → contracts, data-model.md, quickstart.md, agent-specific template file (e.g., `CLAUDE.md` for Claude Code, `.github/copilot-instructions.md` for GitHub Copilot, `GEMINI.md` for Gemini CLI, `QWEN.md` for Qwen Code or `AGENTS.md` for opencode).
7. Re-evaluate Constitution Check section
   → If new violations: Refactor design, return to Phase 1
   → Update Progress Tracking: Post-Design Constitution Check
8. Plan Phase 2 → Describe task generation approach (DO NOT create tasks.md)
9. STOP - Ready for /tasks command
```

**IMPORTANT**: The /plan command STOPS at step 7. Phases 2-4 are executed by other commands:
- Phase 2: /tasks command creates tasks.md
- Phase 3-4: Implementation execution (manual or via tools)

## Summary
Implement the full SQLite tutorial workflow with SQLitch by finishing the remaining command behaviors (`config`, `deploy`, `verify`, `status`, `revert`, `log`, `tag`, `rework`, `engine`) so every step matches Sqitch byte-for-byte. We will leverage the existing registry schema, plan parser, and CLI scaffolding discovered during research to wire commands to real registry operations, identity resolution, and template handling.

## Technical Context
**Language/Version**: Python 3.11
**Primary Dependencies**: Click CLI framework, SQLAlchemy (SQLite engine), python-dateutil, Pydantic, standard library `sqlite3`
**Storage**: SQLite databases for both target schema and Sqitch-compatible registry
**Testing**: pytest with Click `CliRunner`, pytest-randomly, coverage ≥90%
**Target Platform**: Cross-platform CLI (macOS & Linux developers)
**Project Type**: Single Python CLI project with supporting library modules
**Performance Goals**: NFR-003 — `sqlitch deploy` completes <5s for plans under 100 changes on dev hardware
**Constraints**: Behavioral parity with Sqitch (outputs, exit codes, prompts), compact plan format, registry schema identical to Sqitch, silent config writes by default, confirmation required before every revert unless `--yes`
**Scale/Scope**: Tutorial-scale Flipr project (dozens of changes max) plus regression coverage for future parity

## Constitution Check
*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- **Test-First Development:** Phase planning sequences every command enhancement behind new or unskipped contract/integration tests (e.g., tutorial walkthrough scenarios in `tests/cli/commands/`), ensuring we start Red before implementing.
- **Observability & Determinism:** Commands continue to emit human output only unless `--json`/verbosity flags are set; any registry instrumentation stays within SQLite tables with no new log sinks.
- **Behavioral Parity:** All command behaviors are cross-checked against `sqitch/` POD docs and Perl source; deviations (e.g., engine alias handling) are documented in spec clarifications and research notes.
- **Simplicity-First:** Implementation focuses on reusing existing registry + plan modules rather than introducing new abstractions; no additional engines, flags, or output modes beyond tutorial requirements.
- **Documented Interfaces:** Public CLI entry points and helper modules will gain/refresh docstrings as part of implementation, and quickstart plus contracts capture user-facing expectations.

## Project Structure

### Documentation (this feature)
```
specs/004-sqlitch-tutorial-parity/
├── plan.md              # Implementation plan (this file)
├── research.md          # Phase 0 findings (registry parity, engine alias, etc.)
├── data-model.md        # Phase 1 entity/state design
├── quickstart.md        # End-to-end tutorial validation steps
├── contracts/           # CLI contract summaries and references to tests
└── tasks.md             # Generated by /tasks command (not modified here)
```

### Source Code (repository root)
```
sqlitch/
├── __init__.py
├── cli/
│   ├── __init__.py
│   ├── commands/
│   ├── main.py
│   └── options.py
├── config/
├── engine/
├── plan/
├── registry/
└── utils/

tests/
├── cli/
│   ├── commands/
│   └── contracts/
├── integration/
├── registry/
├── regression/
├── support/
└── utils/

sqitch/
├── bin/
└── lib/

docs/
└── architecture/
```

**Structure Decision**: Single-project Python CLI codebase; feature work lives in `sqlitch/` modules with corresponding tests under `tests/`. Upstream Sqitch fixtures remain under `sqitch/` for parity validation.

## Phase 0: Outline & Research
1. Clarified outstanding parity questions (registry schema mirroring, revert confirmation, verify failure flow, engine alias resolution) using Sqitch POD docs and perl implementation; outcomes recorded in `research.md` and the spec clarifications.
2. Validated supporting infrastructure (plan parser, config resolver, registry migrations) to avoid duplicating logic and confirmed required extension points for command implementations.
3. Documented research decisions using the template format (Decision / Rationale / Alternatives) with emphasis on registry operations, identity resolution, and command sequencing. No unresolved clarifications remain.

**Output**: `research.md` (complete — last updated 2025-10-07) capturing parity decisions and remaining implementation gaps.

## Phase 1: Design & Contracts
*Prerequisites: research.md complete*

1. `data-model.md` enumerates the key domain entities (Project, Change, Tag, Dependency, Target, Registry Event, DeployOptions) with attributes, relationships, and lifecycle notes mapped from research + spec.
2. CLI contracts are documented in `contracts/README.md`, pointing to the Click command signatures, expected options, and existing contract tests ensuring Sqitch parity.
3. Quickstart scenarios map the complete tutorial flow (init → add → deploy → verify → status → revert → log → tag → rework) into reproducible validation steps referenced by future integration tests.
4. Agent context (`.github/copilot-instructions.md`) has been refreshed via `.specify/scripts/bash/update-agent-context.sh copilot` after plan updates to ensure tooling awareness of new dependencies and constraints.

**Output**: `data-model.md`, `contracts/README.md`, `quickstart.md`, updated Copilot context — all present under `specs/004-sqlitch-tutorial-parity/`.

## Phase 2: Task Planning Approach
*This section describes what the /tasks command will do - DO NOT execute during /plan*

**Task Generation Strategy**:
- Use `.specify/templates/tasks-template.md` to structure tasks anchored to failing tests first (e.g., tutorial walkthrough integration tests, contract updates for config/revert/log/tag).
- Derive contract-test tasks from `contracts/README.md` gaps (e.g., config get/set, revert prompt, verify failure handling, engine alias acceptance).
- Map each entity/operation in `data-model.md` to implementation tasks (registry mutations, plan formatter updates, script generation behavior).
- Include follow-up tasks for docs/tests (quickstart validation, registry schema assertions) before implementation tasks that satisfy them.

**Ordering Strategy**:
- Maintain Red→Green sequence: add/activate tests per command before coding behavior.
- Respect dependency order: registry model + plan updates precede CLI command wiring; CLI implementations precede documentation polish.
- Use `[P]` markers for independent command tasks (e.g., log vs verify) to highlight parallelizable workstreams.

**Estimated Output**: ~25 ordered tasks balancing test additions, command implementations, and documentation alignment.

**IMPORTANT**: This phase is executed by the /tasks command, NOT by /plan

## Phase 3+: Future Implementation
*These phases are beyond the scope of the /plan command*

**Phase 3**: Task execution (/tasks command creates tasks.md)  
**Phase 4**: Implementation (execute tasks.md following constitutional principles)  
**Phase 5**: Validation (run tests, execute quickstart.md, performance validation)

## Complexity Tracking
*Fill ONLY if Constitution Check has violations that must be justified*

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| _None_ | — | — |


## Progress Tracking
*This checklist is updated during execution flow*

**Phase Status**:
- [x] Phase 0: Research complete (/plan command)
- [x] Phase 1: Design complete (/plan command)
- [ ] Phase 2: Task planning complete (/plan command - describe approach only)
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: PASS
- [x] Post-Design Constitution Check: PASS
- [x] All NEEDS CLARIFICATION resolved
- [x] Complexity deviations documented

---
*Based on Constitution v1.10.1 - See `.specify/memory/constitution.md`*
